#include <iostream>

using namespace std;


/**
 * Функция получения следующей лексикографической перестановки целых чисел
 * (алгоритм Нарайаны).
 *
 * Параметры:
 *  `arr`  : int_ptr    -- указатель на массив целых чисел;
 *  `size` : int        -- размер массива.
 * 
 * Возвращаемое значение: 
 *         : bool       -- была ли получена следующая перестановка.
 */
bool next_permutation(int* arr, int size) {

    // Находим максимальный невозрастающий префикс:
    int index = size;   // - граница префикса;
    // перебираем все элементы массива справа-налево,
    for (int i = size - 1; i > 0; i--) {
        // если находим локальный максимум (точку перегиба), 
        if (arr[i] > arr[i - 1]) {
            index = i;  // то считаем его границей префикса,
            break;      // следующие элементы нас не интересуют.
        }
    }

    // Если максимально возможным искомым префиксом является весь массив,
    // то следующую перестановку получить невозможно -- имеем максимальную.
    if (index == size) { return 0; }

    // Выбираем минимальный элемент из префикса, превосходящий по значению
    // элемент, стоящий перед префиксом, 
    for (int i = size - 1; i > index - 1; i--) {
        if (arr[i] > arr[index - 1]) {
            // меняем из местами.
            swap(arr[i], arr[index - 1]);
            break;
        }
    }

    // Переворачиваем префикс.
    int dist = size - index;
    int seq_size = size;
    for (int i = 0; i < dist / 2; i++) {
        swap(arr[index + i], arr[seq_size - 1 - i]);
    }

    return 1;
}


int main() {

    int n;
    cin >> n;

    int arr[n];
    for (int i = 0; i < n; i++) { arr[i] = i + 1; }

    do {
        for (int i = 0; i < n; i++) 
        {
            cout << arr[i] << ' ';
        }
        cout << endl;
    } while(next_permutation(arr, n));

    return 0;
}